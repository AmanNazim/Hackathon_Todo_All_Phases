# Claude Code Instructions for Phase II Full-Stack Web Todo Application

This document provides specific instructions for Claude Code when generating code for the Phase II Full-Stack Web Todo Application.

## Project Context

- **Project Name**: Phase II Full-Stack Web Todo Application
- **Technology Stack**: Next.js 16+, FastAPI, SQLModel, Neon PostgreSQL, Better Auth
- **Architecture**: Full-stack application with clean separation between frontend and backend
- **Data Storage**: Persistent database storage (Neon Serverless PostgreSQL)
- **Development Methodology**: Spec-Driven Development (Specification → Plan → Tasks → Implementation)

## Core Principles

- **No Manual Coding**: All code must be generated by Claude Code
- **Specification Fidelity**: Implement exactly what's specified, no more, no less
- **Database Persistence**: All data stored in Neon PostgreSQL database using SQLModel
- **Multi-user Support**: Each user has isolated data through authentication
- **Security First**: Proper authentication, authorization, and input validation
- **Modern Web Standards**: Responsive design, RESTful APIs, clean architecture

## Code Generation Guidelines

### Frontend Architecture (Next.js 16+)

1. **Project Structure**:
   - Use App Router (`/app` directory)
   - Component organization: `/components`, `/lib`, `/hooks`, `/types`
   - Page organization with proper layout and loading states
   - Environment configuration for API endpoints

2. **Authentication Integration**:
   - Better Auth client-side integration
   - JWT token management
   - Protected routes and components
   - User session handling

3. **UI Components**:
   - Responsive design with Tailwind CSS
   - Reusable components for task management
   - Loading and error states
   - Form validation and submission

4. **API Integration**:
   - Client-side API calls to FastAPI backend
   - Error handling and user feedback
   - Optimistic updates where appropriate
   - Proper TypeScript typing

### Backend Architecture (FastAPI + SQLModel)

1. **Database Models**:
   - SQLModel models for tasks and users
   - Proper relationships and constraints
   - Database migration considerations
   - Index definitions for performance

2. **API Design**:
   - RESTful endpoints following the specified contract
   - Proper HTTP status codes and error responses
   - Request/response validation with Pydantic
   - Authentication middleware

3. **Authentication Layer**:
   - JWT token generation and validation
   - User identification and authorization
   - Secure password handling
   - Session management

4. **Business Logic**:
   - Task CRUD operations
   - User isolation enforcement
   - Input validation and sanitization
   - Error handling and logging

### Technology Constraints

- **Frontend**: Next.js 16+ with App Router, TypeScript, Tailwind CSS
- **Backend**: FastAPI with SQLModel ORM
- **Database**: Neon Serverless PostgreSQL
- **Authentication**: Better Auth with JWT tokens
- **API Contract**: Strictly follow the specified REST endpoints
- **Type Safety**: Full TypeScript typing on frontend, Pydantic models on backend
- **Security**: JWT-based authentication, input validation, SQL injection prevention

### API-Specific Guidelines

- All endpoints require valid JWT token in `Authorization: Bearer <token>` header
- Requests without token receive 401 Unauthorized
- Each user only sees/modifies their own tasks
- Task ownership enforced on every operation
- Consistent error response format
- Proper HTTP status codes (200, 201, 401, 403, 404, 500)

### Authentication Implementation

1. **Better Auth Configuration**:
   - Enable JWT plugin for token issuance
   - Configure shared secret (BETTER_AUTH_SECRET) for both frontend and backend
   - Set up user registration/login flows

2. **Frontend Integration**:
   - Attach JWT tokens to API request headers
   - Handle token expiration and refresh
   - Protect routes based on authentication status

3. **Backend Middleware**:
   - Verify JWT signatures using shared secret
   - Extract user information from tokens
   - Filter queries by authenticated user ID
   - Enforce user isolation on all operations

### Testing Considerations

- Unit tests for backend API endpoints
- Integration tests for authentication flow
- Frontend component tests
- End-to-end tests for critical user journeys
- Database transaction testing

## Forbidden Implementation Details

- **No In-Memory Storage**: All data must persist in the database
- **No Client-Side Data Manipulation**: All data operations through backend API
- **No Hardcoded Secrets**: Use environment variables for configuration
- **No Insecure Practices**: Proper authentication required for all operations
- **No Cross-User Data Access**: Strict user isolation required
- **No Weak Password Handling**: Use proper hashing and validation

## File Structure Expectations

```
phase-II-todo-full-stack-web-app/
├── frontend/
│   ├── app/
│   │   ├── layout.tsx
│   │   ├── page.tsx
│   │   ├── login/
│   │   ├── dashboard/
│   │   └── api/
│   ├── components/
│   │   ├── TaskList/
│   │   ├── TaskForm/
│   │   └── Auth/
│   ├── lib/
│   │   ├── api.ts
│   │   ├── auth.ts
│   │   └── types.ts
│   ├── hooks/
│   ├── styles/
│   └── package.json
├── backend/
│   ├── main.py
│   ├── models.py
│   ├── database.py
│   ├── auth.py
│   ├── routes/
│   │   ├── tasks.py
│   │   └── auth.py
│   ├── schemas/
│   │   ├── task.py
│   │   └── user.py
│   └── requirements.txt
├── specs/
│   ├── specification.md
│   ├── plan.md
│   └── tasks.md
└── README.md
```

## Quality Standards

- All functions and components must have TypeScript/JSDoc documentation
- Strict type checking on both frontend and backend
- Follow Next.js and FastAPI best practices
- Implement proper error boundaries and fallbacks
- Include comprehensive logging and monitoring
- Follow security best practices for authentication and data protection

## Common Patterns to Use

- React Server Components and Client Components appropriately
- Next.js data fetching patterns (server actions, route handlers)
- FastAPI dependency injection
- SQLModel for database operations
- Context providers for state management
- Custom hooks for reusable logic
- Middleware for authentication and authorization

## Integration Points

- Secure API communication between frontend and backend
- Proper JWT token handling across the stack
- Database connection pooling and optimization
- Environment configuration consistency
- Error handling consistency across both layers