# Claude Code Instructions for Phase I CLI Todo Application

This document provides specific instructions for Claude Code when generating code for the Phase I In-Memory Python CLI Todo Application.

## Project Context

- **Project Name**: Phase I CLI Todo Application
- **Technology Stack**: Python 3.13+, UV package manager
- **Architecture**: CLI application with hybrid interaction modes (menu + natural language)
- **Data Storage**: In-memory only (no persistence)
- **Development Methodology**: Spec-Driven Development (Specification → Plan → Tasks → Implementation)

## Core Principles

- **No Manual Coding**: All code must be generated by Claude Code
- **Specification Fidelity**: Implement exactly what's specified, no more, no less
- **In-Memory Only**: No file I/O, databases, or network operations
- **Python 3.13+ Standards**: Follow modern Python conventions and type hints
- **Clean Architecture**: Maintain separation of concerns between domain, application, and presentation layers

## Code Generation Guidelines

### Architecture Layers

1. **Domain Layer**:
   - Task entity with id, title, description, timestamps, status, tags
   - Value objects and domain services
   - Business logic and validation rules
   - No external dependencies

2. **Application Layer**:
   - Use cases and command handlers
   - Event sourcing implementation
   - Command processing pipeline
   - Input validation

3. **Infrastructure Layer**:
   - CLI interface implementation
   - Command parsing and routing
   - State machine implementation
   - Rendering and output formatting

4. **Presentation Layer**:
   - User interface components
   - Theme management
   - Error handling and user feedback

### Technology Constraints

- Use Python 3.13+ features appropriately (e.g., structural pattern matching, new typing features)
- Utilize standard library where possible (argparse, datetime, uuid, etc.)
- Follow PEP 8 style guidelines
- Include type hints for all public interfaces
- Use dataclasses for value objects and entities
- Implement proper error handling and logging

### CLI-Specific Guidelines

- Support both menu-driven and natural language interaction modes
- Implement BNF grammar-based command parsing
- Provide clear, user-friendly error messages
- Support keyboard shortcuts and quick actions
- Implement proper confirmation dialogs for destructive operations

### Event Sourcing Implementation

- Store all operations as immutable events in memory
- Implement event replay for state reconstruction
- Support undo operations through event reversal
- Maintain chronological order of events
- Implement proper event validation

### Plugin Architecture

- Design extensible interfaces for plugins
- Implement plugin loading and validation
- Ensure plugin safety and isolation
- Support different plugin types (renderer, validator, command, theme)

### Testing Considerations

- Design for testability with dependency injection
- Implement `--test-mode` with JSON output
- Provide mockable interfaces
- Include comprehensive unit tests
- Support integration testing

## Forbidden Implementation Details

- **No persistence**: No file I/O, databases, or storage beyond in-memory
- **No networking**: No HTTP requests, APIs, or network operations
- **No AI/ML**: No machine learning, embeddings, or LLM calls at runtime
- **No external APIs**: No third-party service integration
- **No GUI/web**: Command-line interface only
- **No authentication**: Single-user, no account systems
- **No scheduling**: No background tasks or timers

## File Structure Expectations

```
src/
├── domain/
│   ├── __init__.py
│   ├── entities/
│   ├── value_objects/
│   └── services/
├── application/
│   ├── __init__.py
│   ├── use_cases/
│   ├── commands/
│   └── dtos/
├── infrastructure/
│   ├── __init__.py
│   ├── cli/
│   ├── parsers/
│   └── adapters/
├── presentation/
│   ├── __init__.py
│   ├── renderers/
│   └── themes/
└── __init__.py
```

## Quality Standards

- All functions and classes must have docstrings
- Type hints required for all public interfaces
- Follow SOLID principles
- Implement proper error handling
- Write maintainable and readable code
- Include appropriate logging
- Follow security best practices for input validation

## Common Patterns to Use

- Factory patterns for object creation
- Strategy pattern for different rendering themes
- Command pattern for CLI commands
- Observer pattern for event handling
- State pattern for CLI state management
- Decorator pattern for middleware functionality

## Integration Points

- Ensure clean interfaces between layers
- Use abstract base classes for plugin interfaces
- Implement proper configuration management
- Support dependency injection for testability
- Maintain loose coupling between components